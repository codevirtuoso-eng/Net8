 The core reason is a series of C# compilation errors within your MvcWebApplication project.

Let's break down the errors:

Main Problem: Compilation Errors (CS0117 and CS1061)

These errors mean that your code is trying to use properties or members that don't exist on the specified DTOs (Data Transfer Objects). These DTOs are likely defined in your SharedLibrary project, but the MvcWebApplication (specifically its ViewFunctions) is using them incorrectly or the DTOs are missing expected fields.

Here's a list of the problematic DTOs and the missing properties, along with the files where the errors occur:

In MvcWebApplication/ViewFunctions/ShoppingViewFunctions.cs:
ShoppingCartCreateRequestDTO is missing:
MenuItemId (at line 88)
Quantity (at line 89)
UserId (at line 90)
ShoppingCartGetResponseDTO is missing (or properties are on a nested object):
Quantity (at line 77)
UnitPrice (at line 78)
UnitPrice and Quantity (when accessed together, e.g., for calculation, at lines 79, 81)
ShoppingCartRemoveRequestDTO is missing:
MenuItemId (at line 96)
UserId (at line 97)
ShoppingCartEmptyRequestDTO is missing:
UserId (at line 127)
How to Fix These Errors:

You need to reconcile the definitions of these DTOs (likely in your SharedLibrary project) with how they are being used in MvcWebApplication/ViewFunctions/.

Inspect and Modify Your DTOs:

Open the files where these DTOs are defined (e.g., ShoppingCartCreateRequestDTO.cs, ShoppingCartGetResponseDTO.cs, etc., within your SharedLibrary project).
Ensure they have the properties that ShoppingViewFunctions.cs is trying to access. For example, ShoppingCartCreateRequestDTO should look something like this if those properties are directly on it:
C#

// In SharedLibrary/DTO/ShoppingCart/ShoppingCartCreateRequestDTO.cs (example)
public class ShoppingCartCreateRequestDTO
{
    public int MenuItemId { get; set; } // Or appropriate type
    public int Quantity { get; set; }
    public string UserId { get; set; } // Or appropriate type
    // ... other properties
}
For ShoppingCartGetResponseDTO, if Quantity and UnitPrice belong to individual items in the cart, the DTO might contain a list of item DTOs, and you'd need to iterate through that list in your ShoppingViewFunctions.cs to access those properties. For example:
C#

// In SharedLibrary/DTO/ShoppingCart/ShoppingCartGetResponseDTO.cs (example)
public class ShoppingCartGetResponseDTO
{
    public List<CartItemDTO> Items { get; set; }
    public decimal TotalPrice { get; set; }
    // ... other properties
}

public class CartItemDTO
{
    public int MenuItemId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }
    public decimal LineTotal { get; set; }
}
If this is the case, your ShoppingViewFunctions.cs code would need to be like cartDto.Items.First().Quantity rather than cartDto.Quantity.
Verify Property Names and Types: Double-check for typos in property names and ensure the data types match.

Secondary Issue: Warnings (CS1998)

You also have several warnings like:
CS1998: This async method lacks 'await' operators and will run synchronously.

This warning appears in:

DatabaseAccess/Data/DataAccess/OrderData.cs (lines 53, 60, 67)
MvcWebApplication/Controllers/OrdersController.cs (lines 49, 70, 91)
MvcWebApplication/ViewFunctions/OrdersViewFunctions.cs (lines 99, 104, 110)
MvcWebApplication/ViewFunctions/HomeViewFunctions.cs (line 79)
What CS1998 means:
These methods are declared with the async keyword (e.g., public async Task MyMethod()), but they don't use the await keyword inside them to call other asynchronous methods. This means the method will run synchronously, and the async keyword might be unnecessary or misleading.

How to address CS1998 warnings:

If the method is genuinely intended to perform asynchronous operations, ensure you await those calls (e.g., await _dbContext.SaveChangesAsync();).
If there are no asynchronous operations to await, you can either:
Remove the async keyword and change the return type (e.g., from async Task<MyType> to MyType, or async Task to void, though for Task-returning methods it's better to return Task.FromResult(value) or Task.CompletedTask).
Or, if it's an interface requirement to be async, and there's truly nothing to await, you might use return Task.FromResult<YourExpectedType>(result); or return Task.CompletedTask;.